---
title: The Robotic Nervous System
sidebar_label: 2. ROS 2 Fundamentals
id: 02-ros2-fundamentals
description: Understanding the core architecture of ROS 2.
custom_edit_url: null
experience_level: Beginner
---

# The Robotic Nervous System: ROS 2 Fundamentals

<HeroBox title="How do the eyes talk to the legs?" variant="green">
  <p>
    If the sensors are the eyes and the motors are the muscles, <strong>ROS 2</strong> is the nervous system. It carries the signals that keep your robot alive.
  </p>
</HeroBox>

## Learning Objectives

By the end of this chapter, you will be able to:

-   Define ROS 2 and explain why it is the industry standard.
-   Visualize the "ROS Graph" (Nodes, Topics, Services, Actions).
-   Write a Python agent (`rclpy`) that publishes a heartbeat.
-   Use Launch files to orchestrate multiple nodes.

## 1. What is ROS 2?

The **Robot Operating System (ROS 2)** is not an OS like Windows or Linux; it is **middleware**â€”a software plumbing system that sits on top of the OS to help different parts of your robot talk to each other.

Think of it as the **nervous system** of the robot. It handles:
1.  **Communication:** Letting the camera talk to the brain (Inter-Process Communication).
2.  **Tools:** Visualizing data (Rviz), recording logs (Rosbag2), and inspecting the system (CLI).
3.  **Hardware Abstraction:** Writing code that works on both a simulation and a real robot.

**Why ROS 2?**
*   **Real-time capability (DDS):** It uses Data Distribution Service (DDS) for reliable, real-time communication, critical for safety.
*   **Industry Standard:** Used by NASA, Boston Dynamics, and startups worldwide.
*   **Python support:** First-class support via `rclpy`, making it accessible for rapid prototyping.

## 2. Core Architecture: The "Graph"

ROS 2 organizes software into a network called the **Computational Graph**. You can inspect this graph using tools like `ros2 node list` or visualizers like **Foxglove Studio**.

### Nodes: The Neurons
A **Node** is a single, independent process that performs a specific task.
*   `camera_node`: Reads data from the camera driver.
*   `motor_node`: Sends voltage commands to the wheel controllers.
*   `brain_node`: Processes sensor data to decide where to go.

You can inspect a node's connections with:
```bash
ros2 node info /my_node_name
```

### Topics: The Veins (Streaming Data)
Nodes communicate via **Topics** using a **Publish/Subscribe** model. This is a unidirectional stream of data for continuous updates (e.g., sensor data, robot velocity).
*   **Example:** `camera_node` *publishes* `sensor_msgs/Image` to the topic `/camera/raw`. The `brain_node` *subscribes* to that topic to "see".

### Services: The Reflex (Request/Response)
For quick, synchronous interactions. You ask a question, you get an answer.
*   **Example:** "Reset Odometry" or "Calibrate IMU".
*   **Command:** `ros2 service call /reset_odom ...`

### Actions: The Long-Term Goals
For tasks that take time and provide feedback. They are asynchronous and cancellable.
*   **Example:** "Walk to the kitchen." This takes 30 seconds. The robot provides feedback ("I am 50% there") and you can cancel it ("Stop! There is a cat.").
*   **Structure:** Consists of a Goal, Feedback, and Result.

## 3. Orchestration: Parameters & Launch Files

### Parameters
Dynamic configuration variables stored inside a node.
*   Instead of hardcoding `max_speed = 5.0` in your code, you use a ROS Parameter.
*   This lets you change the speed limit at runtime without recompiling code using `ros2 param set`.

### Launch Files: The Conductor
You don't want to open 20 terminal windows to start 20 nodes manually.
**Launch Files** (Python, XML, or YAML) allow you to start the entire robot system (Camera + Motor + Brain + State Publishers) with one command.

```python
# Example: my_robot.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_package',
            executable='motor_controller',
            name='motor_node',
            # Remapping allows you to connect nodes dynamically
            remappings=[('/cmd_vel', '/robot/cmd_vel')],
            parameters=[{'speed_limit': 2.5}]
        )
    ])
```

## 4. The "Hello Robot" Code Lab

Let's write a simple Python Agent using `rclpy` that acts as a "Heartbeat," proving our robot is alive. This node will publish a message every second.

### The Code

<Tabs>
  <TabItem value="python" label="Python Agent (rclpy)" default>

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class HeartbeatNode(Node):
    def __init__(self):
        # Initialize the node with the name 'heartbeat'
        super().__init__('heartbeat')
        
        # Create a publisher on the topic 'status' with a queue size of 10
        # Queue size is part of QoS (Quality of Service)
        self.publisher_ = self.create_publisher(String, 'status', 10)
        
        # Create a timer to run the callback every 1.0 second (1Hz)
        self.timer = self.create_timer(1.0, self.publish_status)
        self.get_logger().info('Heartbeat Node Started')

    def publish_status(self):
        msg = String()
        msg.data = 'Alive'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')

def main(args=None):
    # Initialize the ROS 2 communication
    rclpy.init(args=args)
    
    node = HeartbeatNode()
    
    # Spin the node so it can process callbacks
    rclpy.spin(node)
    
    # Destroy the node explicitly (optional but recommended)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

  </TabItem>
</Tabs>

<SimToRealWarning>
  On your workstation, this 1Hz loop runs perfectly. On a real robot, if the CPU is overloaded by vision processing, your heartbeat might lag. Real-time systems require careful **QoS (Quality of Service)** tuning (e.g., setting `Reliability` to `Best Effort` for sensor data) to ensure critical messages aren't dropped.
</SimToRealWarning>

### Running the Node

1.  **Start the node:**
    ```bash
    python3 heartbeat_node.py
    ```
2.  **Listen to the topic (in a new terminal):**
    ```bash
    ros2 topic echo /status
    ```
    *You should see: `data: "Alive"` printing every second.*

---

**Next:** Now that our software is talking, let's look at how we define the robot's physical body using **URDF**.